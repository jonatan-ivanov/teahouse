ext.buildTime = new Date().toInstant()

buildscript {
    ext.springBootVersion = 'latest.release'
    ext.springCloudVersion = 'latest.release'
    ext.springDataVersion = 'latest.release'

    configurations.classpath {
        resolutionStrategy.activateDependencyLocking()
    }

    repositories {
        gradlePluginPortal()
    }
    dependencies {
        classpath 'org.ajoberstar.grgit:grgit-gradle:latest.release'
        classpath 'com.gorylenko.gradle-git-properties:gradle-git-properties:latest.release'
        classpath "org.springframework.boot:spring-boot-gradle-plugin:$springBootVersion"
    }
}

task clean

apply plugin: 'org.ajoberstar.grgit'
apply from: "$rootDir/gradle/idea.gradle"

allprojects {
    task cleanAll {
        description = 'Deletes the build directory and the IDE files and directories'
        group = 'build'
        dependsOn clean, cleanIdea, cleanIdeaWorkspace
        doLast {
            delete 'out', '.idea'
        }
    }
}

subprojects {
    if (project.name != 'load-gen') {
        apply plugin: 'java'
        apply from: "$rootDir/gradle/dependency-locking.gradle"

        sourceCompatibility = JavaVersion.VERSION_18
        targetCompatibility = JavaVersion.VERSION_18

        group = 'org.example.teahouse'
        ext.commitId = grgit ? grgit.head().id : System.env.SOURCE_VERSION ?: 'N/A'
        ext.abbreviatedCommitId = grgit ? grgit.head().abbreviatedId : ext.commitId.take(7)
        version = "${abbreviatedCommitId}.${buildTime.toEpochMilli()}"

        repositories {
            mavenCentral()
        }

        dependencies {
            ['annotationProcessor', 'compileOnly', 'implementation', 'runtimeOnly', 'testImplementation'].each { conf ->
                dependencies.add(conf, platform("org.springframework.boot:spring-boot-dependencies:$springBootVersion"))
                dependencies.add(conf, platform("org.springframework.cloud:spring-cloud-dependencies:$springCloudVersion"))
                dependencies.add(conf, platform("org.springframework.data:spring-data-bom:$springDataVersion"))
                dependencies.add(conf, platform('org.zalando:logbook-bom:latest.release'))
            }
            testImplementation platform('org.junit:junit-bom:latest.release')

            annotationProcessor 'org.projectlombok:lombok'
            compileOnly 'org.projectlombok:lombok'

            testImplementation 'org.junit.jupiter:junit-jupiter-api'
            testImplementation 'org.junit.jupiter:junit-jupiter-params'
            testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine'
        }

        jar.manifest.attributes(
            'Name': project.name,
            'Implementation-Build-Date': buildTime,
            'Implementation-Title': project.name,
            'Implementation-Version': project.version,
            'Implementation-Vendor': project.group,
            'Commit-AbbreviatedId': abbreviatedCommitId,
            'Commit-Id': commitId,
            'Commit-Date': grgit ? grgit.head().getDate().toInstant() : 'N/A',
            'Source-Path': grgit ? grgit.remote.list().findResult { it.name == 'origin' ? it.url : null } : 'N/A',
            'Created-By': "Gradle ${gradle.gradleVersion} with Gradle Ghost (grg)",
            'Built-By': System.properties['user.name'],
            'JDK': org.gradle.internal.jvm.Jvm.current(),
            'OS': org.gradle.internal.os.OperatingSystem.current()
        )

        test {
            useJUnitPlatform()
        }
    }
}

task stage {
    dependsOn ":${System.getenv()['PROJECT_NAME']}:herokuStage"
}

wrapper {
    distributionType = Wrapper.DistributionType.BIN
    // gradleVersion = new groovy.json.JsonSlurper().parseText('https://services.gradle.org/versions/current'.toURL().text).version
}
